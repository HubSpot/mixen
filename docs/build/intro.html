<h1>Mixen</h1>
<p>Mixen lets you combine classes on the fly.  With it you can build smaller, easier to understand and
more testable components, and more easily share code with others.  <strong>It does not just merge the prototypes.</strong></p>
<pre><code class="lang-coffeescript">class MyModel extends Mixen(Throttle, APIBinding, Validate, Backbone.Model)
  # Inheritance Chain:
  #
  # MyModel -&gt; Throttle -&gt; APIBinding -&gt; Validate -&gt; Backbone.Model


class MyOtherModel extends Mixen(APIBinding, Backbone.Model)
  # Inheritance Chain:
  #
  # MyOtherModel -&gt; APIBinding -&gt; Backbone.Model</code></pre>
<p>The 2kb library only exposes a single function, <code>Mixen</code>.  This function allows you to combine
classes together in such a way that the <code>super</code> keyword will dynamically call the appropriate method in the
next mixin you&#39;re using.</p>
<blockquote>
<p>Note:</p>
<p>These examples are in CoffeeScript.  Skip down to the bottom for a short description of how
this can be done with JavaScript.</p>
</blockquote>
<h3>Usage</h3>
<p>Feel free to <a href="http://jsfiddle.net/4XgaR/7/">start playing with Mixen</a> right now.</p>
<p>On the browser include <a href="https://github.com/HubSpot/Mixen/blob/master/mixen.min.js">mixen.min.js</a>, and the <code>Mixen</code> function will be globally available.
You can also use AMD.</p>
<p>On node:</p>
<pre><code class="lang-bash">npm install mixen</code></pre>
<pre><code class="lang-coffeescript">Mixen = require(&#39;mixen&#39;)</code></pre>
<p>The Mixen function takes in any number of classes, and returns an object:</p>
<pre><code class="lang-coffeescript">MyObject = Mixen(Object1, Object2, ...)</code></pre>
<h3>Example</h3>
<p>A mixin is just a class:</p>
<pre><code class="lang-coffeescript">class OnlyRenderWithModel
  render: -&gt;
    return unless @model

    super</code></pre>
<p>Any view who would like your method can now use Mixen to mix you in:</p>
<pre><code class="lang-coffeescript">class MyView extends Mixen(OnlyRenderWithModel, Backbone.View)</code></pre>
<p>You can now replace your BaseModels and BaseViews with modular components.</p>
<h3>Multiple Mixins Which Share Methods</h3>
<p>Mixen adds one very important capability to inheritance, the ability to have multiple mixins all implement the same method.</p>
<pre><code class="lang-coffeescript">class CountSyncs
  sync: -&gt;
    @syncs ?= 0
    @syncs++

    super</code></pre>
<pre><code class="lang-coffeescript">class ThrottleSyncs
  sync: -&gt;
    return if @syncing
    @syncing = true

    super.finally =&gt;
      @syncing = false</code></pre>
<p>Now, you can mix in both classes.  When the first mixin calls <code>super</code>, it will dynamically find and call the second
mixin&#39;s <code>sync</code> method.</p>
<pre><code class="lang-coffeescript">class MyModel extends Mixen(ThrottleSyncs, CountSyncs, Backbone.Model)</code></pre>
<p><code>MyModel</code> will both throttle it&#39;s sync&#39;s and keep track of it&#39;s sync count.</p>
<p>Note that the count <code>CountSyncs</code> will change depending on if it is listed before or after
<code>ThrottleSyncs</code>.  All methods are resolved from left to right.  In other words,
when you call <code>super</code>, you are calling the mixin to the current mixins right.</p>
<h4>The End of the Chain</h4>
<p>When you&#39;re developing a mixin, you don&#39;t know if your mixin will be the last in a chain used
to create a class or not.  Therefore you must always call super (unless you want to break the chain), and
you must always be ready for <code>super</code> to return undefined (as it will if there are no more classes mixed in
which implement that method).</p>
<pre><code class="lang-coffeescript">class UserInContext
  getContext: -&gt;
    context = super ? {}
    context.user = &#39;bob smith&#39;
    context

class AuthInContext
  getContext: -&gt;
    context = super ? {}
    context.auth = &#39;logged-in&#39;
    context</code></pre>
<p>Each getContext method will be called, in the order they are defined in the Mixen call:</p>
<pre><code class="lang-coffeescript">class MyView extends Mixen(AuthInContext, UserInContext, Backbone.View)
  getContext: -&gt;
    context = super
    context.x = 2
    context</code></pre>
<h3>Mixening in Constructors</h3>
<p>Mixins can have constructors.  As long as the resultant class either does not have a constructor,
or calls <code>super</code> in it&#39;s constructor, all of the mixins constructors will be called in the order
they are defined.  If you do not wish for the constructors to be called, simply don&#39;t call super
in the constructor of the class extending the mixen.</p>
<pre><code class="lang-coffeescript">class CallInitialize
  constructor: -&gt;
    @initialize?()</code></pre>
<pre><code class="lang-coffeescript"># initialize will be called
class MyThing extends Mixen(CallInitialize)

# initialize will be called
class MyThing extends Mixen(CallInitialize)
  constructor: -&gt;
    # Do whatever other stuff you want...

    super

# initialize WON&#39;T be called
class MyThing extends Mixen(CallInitialize)
  constructor: -&gt;
    # Never called super...</code></pre>
<p>Note, that unlike the other methods, mixins should not call <code>super</code> in their constructors.  This is
necessary because, unlike with standard methods, all classes have a constructor, even if you never
explicitly implemented one.  This means that if we made you call <code>super</code>, you would have to explicitly
call <code>super</code> in each constructor, even when you don&#39;t care to specify one.  To keep things simple, we
always call all the mixin&#39;s constructors in the order they are specified, provided the mixing class doesn&#39;t
explicitly prevent it.</p>
<h3>Aliases</h3>
<p>Mixen doesn&#39;t create them for you, but you&#39;re more than welcome to create some helpful aliases as you need:</p>
<pre><code class="lang-coffeescript">Mixen.View = (modules...) -&gt;
  Mixen(modules..., Backbone.View)</code></pre>
<p>You can do a similar thing to create a default list of mixins for your application:</p>
<pre><code class="lang-coffeescript">ViewMixen = (modules...) -&gt;
  Mixen(modules..., EventJanitor, Backbone.View)</code></pre>
<h3>Composition</h3>
<p>You can safely mixin other mixens:</p>
<pre><code class="lang-coffeescript">BaseView = Mixen(EventJanitor, Backbone.View)

class MyView extends Mixen(SuperSpecialModule, BaseView)</code></pre>
<h3>Not Using CoffeeScript?</h3>
<p>If you&#39;re not using CoffeeScript, it is possible to write the necessary js manually.  Replicating CoffeeScript&#39;s
inheritance mechanism is fairly complicated however.  It requires a robust extension mechanism, and replacing every
<code>super</code> call used above with <code>ModuleName.__super__.methodName</code>.</p>
<pre><code class="lang-javascript">var AuthInContext, MyView, UserInContext;

UserInContext = function (){}

UserInContext.prototype.getContext = function(){
  var context;

  context = UserInContext.__super__.getContext.apply(this, arguments) || {};
  context.user = &#39;bob smith&#39;;
  return context;
};

AuthInContext = function (){}

AuthInContext.prototype.getContext = function(){
  var context;

  context = AuthInContext.__super__.getContext.apply(this, arguments) || {};
  context.auth = &#39;logged-in&#39;;
  return context;
};

MyView = function (){
  return MyView.__super__.constructor.apply(this, arguments);
}

__extends(MyView, Mixen(AuthInContext, UserInContext, Backbone.View));

MyView.prototype.getContext = function(){
  var context;

  context = MyView.__super__.getContext.apply(this, arguments);
  context.x = 2;
  return context;
};</code></pre>
<p>Where <code>__extends</code> is implemented as:</p>
<pre><code class="lang-coffeescript">var __hasProp = {}.hasOwnProperty,
__extends = function(child, parent){
  for (var key in parent) {
    if (__hasProp.call(parent, key))
      child[key] = parent[key];
  }

  function ctor() {
    this.constructor = child;
  }

  ctor.prototype = parent.prototype;
  child.prototype = new ctor();
  child.__super__ = parent.prototype;

  return child;
};</code></pre>
<h3>Debugging</h3>
<p>If it&#39;s not working the way you expect, it&#39;s usually because you forgot to call <code>super</code> in one of your methods.</p>
<p>Take a look at the tests for complete examples of how things should work.</p>
<p>You can always ask us for help in GitHub Issues.</p>
<h3>Support</h3>
<p>Mixen is tested in IE6+, Firefox 3+, Chrome 14+, Safari 4+, Opera 10+, Safari on iOS 3+, Android 2.2+ and Node 0.8+.</p>
<h3>Contributing</h3>
<p>We welcome pull requests and discussion using GitHub Issues.</p>
<p>To get setup for development, run this in the project directory:</p>
<pre><code class="lang-bash">npm install</code></pre>
<p>Then, you can run <code>grunt watch</code> to have it watch the source files for changes.
Run <code>grunt test</code> to ensure that the tests still pass.
You can also open <code>spec/vendor/jasmine-1.3.1/SpecRunner.html</code> in your browser to check the tests (after doing a <code>grunt</code> build).</p>
<p>If you develop a mixin others might find useful, please name the repo <code>mixen-contrib-&lt;name&gt;</code> and publish it on npm under the
same name with the &#39;mixen&#39; tag.</p>
<p>Please let us know of any interesting Mixen&#39;s you make!</p>
<h3>Changelog</h3>
<ul>
<li>0.5.0 - Initial public release</li>
</ul>
